/** * Not for commerical use * @author: paddy.keane@wai.co.uk **/package{		import away3d.cameras.*;	import away3d.containers.*;	import away3d.core.base.*;	import away3d.core.filter.*;	import away3d.core.render.*;	import away3d.core.utils.*;	import away3d.events.*;	import away3d.lights.*;	import away3d.loaders.*;	import away3d.materials.*;	import away3d.primitives.*;	import away3d.sprites.*;	import away3d.test.Button;		import com.as3dmod.ModifierStack;	import com.as3dmod.modifiers.*;	import com.as3dmod.plugins.away3d.LibraryAway3d;	import com.as3dmod.util.ModConstant;	import com.bit101.components.HUISlider;		import flash.display.*;	import flash.events.*;	import flash.filters.*;	import flash.geom.*;	import flash.text.*;	import flash.utils.*;		import gs.*;	import gs.easing.*;	import net.hires.debug.Stats;		[SWF(backgroundColor="#fdfdfd", frameRate="60", quality="MIDDLE", width="1024", height="768")]		public class Spiral3D extends Sprite	{    	private var spiralScene:Scene3D;		private var spiralCamera:Camera3D;		private var spiralView:View3D;				private var foregroundScene:Scene3D;		private var foregroundCamera:Camera3D;		private var foregroundView:View3D;					private var holder:ObjectContainer3D		private var scroller:HUISlider;				private var lastPanAngle:Number;		private var lastTiltAngle:Number;		private var lastMouseX:Number;		private var lastMouseY:Number;				private var total:int;		private var numOfRotations:int;		private var anglePer:Number;		private var yPos:Number = 0;		private var angle:Number = 0;		private var itemsLoaded:Number = 0;				private var imageWidth:int = 140;		private var imageHeight:int = 105;				private var items:Array = [];		private var categoryColorMaterials:Array = [];						private var selectedItemRef: ObjectContainer3D;      		 		private var selectedItemMaterial: IMaterial;        private var selectedItemOverlay: Plane;        private var selectedItemContainer: ObjectContainer3D;        					private var selectedItemStack: ModifierStack;        private var selectedItemWindMod: Perlin;		private var selectedItemPaperMod: Bend;		private var closeButton:Button;		private var selectedContent:Sprite;				private var loadingTxt:TextField;				private var scrollerValue:Number = 0;					private var active:Boolean = true;		private var moving:Boolean = true;		private var currentSlideIndex:int = 0;				public function Spiral3D()		{			init();		}		        		private function init():void		{			initEngine();			initMaterials();			initObjects();			initListeners();		}				private function initEngine():void		{			 var format:TextFormat = new TextFormat();            format.font = "Verdana";            format.color = 0x666666;            format.size = 14;            			loadingTxt = new TextField();            loadingTxt.x = 280;            loadingTxt.y = 240;            loadingTxt.autoSize =  TextFieldAutoSize.LEFT;            loadingTxt.defaultTextFormat = format;            addChild(loadingTxt);			addChild(new Stats());            loadingTxt.text = "Loading items, please wait...";            						spiralScene = new Scene3D();						spiralCamera = new Camera3D({zoom:10, focus:50, x:1000, y:0, z:-500});						//create a renderer using the filter   			var basicrenderer:IRenderer = new BasicRenderer();  			spiralView = new View3D({scene:spiralScene, camera:spiralCamera, renderer:basicrenderer});			addChild( spiralView );						scroller = new HUISlider();			scroller.width = 800;			scroller.y = 650;			scroller.minimum = 0;			scroller.maximum = 1;			scroller.value = scroller.maximum;			//addChild(scroller);						var helpTxt:TextField = new TextField();            helpTxt.x = 10;            helpTxt.y = 670;            helpTxt.autoSize =  TextFieldAutoSize.LEFT;                        helpTxt.defaultTextFormat = format;            //addChild(helpTxt);            helpTxt.text = "Use the scroller to navigate along the spiral, click an item to select it";            			foregroundScene = new Scene3D();			foregroundCamera = new Camera3D({zoom:1, focus:0, z:-500});            //create foreground view and add to displaylist            foregroundView = new View3D({camera:foregroundCamera, scene:foregroundScene, renderer:new BasicRenderer()});            addChild(foregroundView);                        selectedContent = new Sprite();            selectedContent.x = 40;            selectedContent.y = 40;            selectedContent.visible = false;            addChild(selectedContent);                        // test            //TODO: refactor so content can be dynamic,based on selectedItems data            /////////////////////////////////            var testTxt:TextField = new TextField();            testTxt.x = 280;            testTxt.y = 240;            testTxt.autoSize =  TextFieldAutoSize.LEFT;            testTxt.defaultTextFormat = format;            selectedContent.addChild(testTxt);                        testTxt.text = "Content Placeholder";            ////////////////////////////////////                        closeButton = new Button("Close", 52);            closeButton.x = 690;            closeButton.y = 40;            closeButton.visible = false;            addChild(closeButton);                        total = 90;			numOfRotations = Math.ceil(total/30);			anglePer = ((Math.PI*2) * numOfRotations) / total;                        stage.addEventListener(Event.RESIZE, onResize);            onResize(null);		}				/**		 * Initialise the materials		 */		private function initMaterials():void		{						categoryColorMaterials.push( new ColorMaterial(0x245C54));			categoryColorMaterials.push( new ColorMaterial(0xFFCA8E));			categoryColorMaterials.push( new ColorMaterial(0xEDA062));					categoryColorMaterials.push( new ColorMaterial(0xE57734));		   		}		//FF4000		/**		 * Initialise the scene objects		 */		private function initObjects():void		{						holder = new ObjectContainer3D();			holder.visible = false;			spiralScene.addChild(holder);			var mat:WireColorMaterial = new WireColorMaterial();			mat.color = 0xededed;			mat.wirecolor = 0x999999;						for( var i:int = 0; i < total; i++ )			{								var background_material:ColorMaterial = ColorMaterial(categoryColorMaterials[Math.floor(i/2)%4]);																									//var image_material:BitmapFileMaterial = new BitmapFileMaterial("thumbnails/"+data[i].filename);								var image_material:BitmapFileMaterial = new BitmapFileMaterial("assets/green.png");												image_material.addEventListener(MaterialEvent.LOAD_SUCCESS, onItemLoadSuccess);								var image_plane:Sphere = new Sphere({material:((Math.floor(i/2)%4==0) ? background_material : mat),radius:14,segmentsW:4,segmentsH:2});				/*var image_plane:Plane = new Plane({										material:image_material,										width:imageWidth-8,										height:imageHeight-8,										y:1,										segmentsW:2,										segmentsH:2,										ownCanvas:true,										bothsides:true										});																														image_plane.lookAt(foregroundCamera.position);						*/				var itemContainer:ObjectContainer3D = new ObjectContainer3D({name:"itemContainer_"+i, ownCanvas:true}, image_plane );								holder.addEventListener(MouseEvent3D.MOUSE_OVER, onRollover);				holder.addEventListener(MouseEvent3D.MOUSE_OUT, onRollout);				itemContainer.addEventListener(MouseEvent3D.MOUSE_DOWN, onClick);								itemContainer.useHandCursor = true;								//var glow:GlowFilter = new GlowFilter(background_material.color, 0, 10, 10);				//image_plane.filters = [glow];								// randomally position them so they can animate in on intro				if(i%2 == 0){					itemContainer.x = yPos += 25;					itemContainer.z = Math.sin(-i * anglePer) * 100;					itemContainer.y = Math.cos(i * anglePer) * 100;					//itemContainer.rotationX = ((i*anglePer) * ((180)/Math.PI)) % 360;				//itemContainer.extra = {index:i, colorMaterial:background_material, glow:glow};				} else {					itemContainer.x = yPos;					itemContainer.z = -Math.sin((-i+1) * anglePer) * 100;					itemContainer.y = -Math.cos((i-1) * anglePer) * 100;				//	itemContainer.rotationX = ((i*anglePer) * (180/Math.PI)) % 360;				}				holder.rotationZ = 90;								holder.addChild(itemContainer);								// store a list of items				items.push(itemContainer);			}	import flash.events.Event;import flash.display.Stage;									            selectedItemOverlay = new Plane({ownCanvas:true, width:800, height:600, segmentsW:20, segmentsH:20, bothsides:true, yUp:false});            selectedItemOverlay.visible = false;            selectedItemOverlay.alpha = 0;                           selectedItemContainer = new ObjectContainer3D({}, selectedItemOverlay );          						foregroundScene.addChild(selectedItemContainer)						selectedItemStack = new ModifierStack(new LibraryAway3d(), selectedItemOverlay);            selectedItemWindMod = new Perlin(.2, 25, 25, 95840);			selectedItemPaperMod = new Bend(0, .2, .4);			selectedItemPaperMod.constraint = ModConstant.RIGHT;			selectedItemStack.addModifier(selectedItemPaperMod);			selectedItemStack.addModifier(selectedItemWindMod);			            		}				/**		 * Initialise the listeners		 */		private function initListeners():void		{					addEventListener( Event.ENTER_FRAME, onEnterFrame );			scroller.addEventListener(Event.CHANGE, onScrollHandler);			closeButton.addEventListener(MouseEvent.CLICK, onCloseClick);		}						/**		 * all thumbs are loaded		 * (if lots of items are required this feature may need to be disabled		 * or handled by a proirity que)		 */		private function onItemLoadSuccess(e:MaterialEvent):void		{			itemsLoaded ++;			if (itemsLoaded == total)			{				removeChild(loadingTxt);				intro();			}		}				/**		 * play the intro animation		 */		private function intro():void		{			holder.visible = true;			// animate in the individual items			for( var i:int = 0; i < total; i++ )			{														var itemContainer:ObjectContainer3D = items[i];				/*				TweenLite.to(itemContainer,4, {					z:Math.sin(-i * anglePer) * 200,					y:Math.cos(i * anglePer) * 200,						rotationX:((i*anglePer) * (180/Math.PI)) % 360,					ease:Quad.easeOut				});				*/							}							// move camera along the length of the spiral to give			// user an idea about it's dimensions			var spiralPos:Object = calculateSpiralPosition();						holder.rotationX = spiralPos.rotation;			spiralCamera.x = spiralPos.xPos+150;			//spiralCamera.y += 200;			spiralCamera.z = -550;			spiralCamera.rotationY = 0;			spiralCamera.focus = 50;			TweenLite.to(spiralCamera, 5,	{y:spiralCamera.y+550});					}				/**		 * move sprial when scroller is scrolled		 **/				private function onScrollHandler(e:Event):void		{			moveSpiral();					}				/**		 * Move sprial based on scrollbar position		 **/		private function moveSpiral():void		{			var spiralPos:Object = calculateSpiralPosition()						TweenLite.to(holder, 3,	{ rotationX:spiralPos.rotation });			TweenLite.to(spiralCamera, 3,	{ x:spiralPos.xPos }); 		}				/**		 * Calculate where sprial should move to based on scrollbar position		 **/		private function calculateSpiralPosition():Object		{			var rotation:Number = -(360 * (numOfRotations) * scrollerValue) + 90 + (36 * scrollerValue)%360;				var xPos:Number = (holder.objectWidth * scrollerValue) + (imageWidth *(1 - scrollerValue));			return {rotation:rotation, xPos:xPos}		}				 /**		 * Item Rollover		 **/	    private function onRollover(e:MouseEvent3D):void	    {	    	//moving = false;			//.removeEventListener(Event.ENTER_FRAME, onEnterFrame);	    	//TweenLite.to(item.extra.glow, .5,	{ alpha:.85 });    	    }	    	    /**		 * Item Rollout		 **/	    private function onRollout(e:MouseEvent3D):void	    {			//moving = true;			//this.addEventListener(Event.ENTER_FRAME, onEnterFrame);	      //  var item:ObjectContainer3D = ObjectContainer3D(e.target);	    	//TweenLite.to(item.extra.glow, .5,	{ alpha:0 });   		    }	    	    /**		 * Item Click		 **/	    private function onClick(e:MouseEvent3D):void	    {			trace("DO");	    	//if (selectedItemRef) return;	    		       	var item:ObjectContainer3D = ObjectContainer3D(e.target);	       	selectedItemRef = item;	       				trace("OK 1");			//selectedItemOverlay.visible = true;			//selectedItemOverlay.material = selectedItemRef.extra.colorMaterial;			//selectedItemPaperMod.constraint = ModConstant.LEFT;						trace("OK2");			selectedItemOverlay.x = item.scenePosition.x;			selectedItemOverlay.y = item.scenePosition.y;			selectedItemOverlay.z = item.scenePosition.z;			selectedItemOverlay.scaleX = imageWidth/800;			selectedItemOverlay.scaleY = imageHeight/600;			selectedItemOverlay.alpha = item.alpha;			trace("OK3");									selectedItemOverlay.rotationX = ((item.rotationX + holder.rotationX + 90) %360) + 360;												foregroundCamera.zoom 	=	spiralCamera.zoom;			foregroundCamera.focus 	=	spiralCamera.focus;			foregroundCamera.x 		=	spiralCamera.x;			foregroundCamera.y 		=	spiralCamera.y;			foregroundCamera.z 		=	spiralCamera.z;									//trigger animation by fading overlay in first			//TweenLite.to(selectedItemRef, .4, {alpha:0});				TweenLite.to(spiralCamera, 5,	{ rotationZ:180, z:item.scenePosition.z-10, x: item.scenePosition.x, y:item.scenePosition.y});			moving = false;					//TweenLite.to(selectedItemOverlay, .4, {alpha:item.alpha, onComplete:onSelectedItemFadeInComplete});		    }	    	    /**	    * start the selectedItemOverlay Flip	    **/	    private function onSelectedItemFadeInComplete():void		{			TweenLite.to(foregroundCamera, 1.5, {zoom:3, focus:200, x:0, y:0, z:-1000});			TweenLite.to(selectedItemOverlay,1.5, {alpha:1, x:0, y:0, z:-550, rotationX:180, rotationY:180, scaleX:1, scaleY:1, ease:Quad.easeOut, onComplete:setTimeout, onCompleteParams:[onItemSelectedAnimationComplete, 200]});			TweenLite.to(selectedItemPaperMod, .7, {force:1, ease:Quad.easeOut, onComplete:onBendEnd});		}				/**	    * bend has ended, now lower the force so the perlin doesn't carry on	    **/	    private function onBendEnd():void		{			TweenLite.to(selectedItemPaperMod, .7, {force:0, ease:Quad.easeOut});		}				/**	    * selected item content closed	    **/		private function onCloseClick(e:MouseEvent):void	    {	       	closeButton.visible = false;	       	selectedContent.visible = false;	       	active = true;	       		        selectedItemPaperMod.constraint = ModConstant.LEFT;	       				var xPos:Number = selectedItemRef.scenePosition.x;			var yPos:Number = selectedItemRef.scenePosition.y;			var zPos:Number = selectedItemRef.scenePosition.z;			var xRotation:Number = ((selectedItemRef.rotationX + holder.rotationX + 90) %360) + 360;						//trigger animation			TweenLite.to(foregroundCamera, 1.5, {zoom:spiralCamera.zoom, focus:spiralCamera.focus, x:spiralCamera.x, y:spiralCamera.y, z:spiralCamera.z});					TweenLite.to(selectedItemOverlay,1.5, {alpha:getItemAlpha(selectedItemRef), x:xPos, y:yPos, z:zPos, rotationX:xRotation, rotationY:0, scaleX:imageWidth/800, scaleY:imageHeight/600, ease:Quad.easeOut, onComplete:setTimeout, onCompleteParams:[onItemDeselectedAnimationComplete, 200]});			TweenLite.to(selectedItemPaperMod, .7, {force:1, ease:Quad.easeOut, onComplete:onBendEnd});				    }	    	    /**	    * Selected Item transition finished	    * we can now show the content	    **/	    private function onItemSelectedAnimationComplete():void		{			showSelectedContent();			selectedItemStack.mesh.resetGeometry();            foregroundView.render();		}				private function showSelectedContent():void		{			active = false;			closeButton.visible = true;			selectedContent.visible = true;		}				/**	    * Deselected Item transition finished	    * we need to reset the modifer stack in preperation	    * for next selection	    **/		private function onItemDeselectedAnimationComplete():void		{				selectedItemRef.visible = true;			selectedItemRef.alpha = 0;						TweenLite.to(selectedItemOverlay,.4, {alpha:0, onComplete:onItemDeselectedFadeOutComplete});			TweenLite.to(selectedItemRef,.4, {alpha:getItemAlpha(selectedItemRef)});						            selectedItemStack.mesh.resetGeometry();		}				/**		 * autoAlpha doesn't seem to work so need to set visiblity to false		 * so sprial items are clickable again		 **/		private function onItemDeselectedFadeOutComplete():void		{					selectedItemOverlay.visible = false;			selectedItemRef = null;			}						/**		 * set 'depth of field' using blur and Render		 **/		private function onEnterFrame(event:Event):void		{			if (!active)                return;						 spiralView.render();        	 foregroundView.render();			for( var i:int = 0; i < total; i++ )			{				/*var item:ObjectContainer3D = items[i];				var blur:BlurFilter = new BlurFilter(4,4,1);				var d:Number = item.distanceTo(spiralCamera);				blur.blurX = uint((d - 514) * 0.02);				blur.blurY = uint((d - 514) * 0.02);				item.filters = [blur];				if (item != selectedItemRef) item.alpha = getItemAlpha(item);				*/				//item.ownSession.getContainer(spiralView).alpha = 314/d;				//item.position.toString()				//if (d < 310) trace(d);			}			//trace(items[total-1].distanceTo(spiralCamera));						//update modifiers			selectedItemStack.apply();						if(!moving){				return;			}															            //update views          			scrollerValue += (100/(this.stage as Stage).frameRate)/1000;			//if(scroller.value == 1) scroller.value = 0;			var spiralPos:Object = calculateSpiralPosition()						//TweenLite.to(holder, 3,	{ rotationX:spiralPos.rotation });			//TweenLite.to(spiralCamera, 3,	{ x:spiralPos.xPos }); 						TweenLite.to(holder,1, {rotationX:spiralPos.rotation});					}				/**		 * set item alpha based on distance from camera		 **/		private function getItemAlpha(item:ObjectContainer3D):Number        {        	var d:Number = item.distanceTo(spiralCamera);        	return (314/d) * 1.5;        }     	     	/**     	 * Reposition viewport based on stage size     	 **/        private function onResize(event:Event):void         {            foregroundView.x = spiralView.x = stage.stageWidth / 2;            foregroundView.y = spiralView.y = stage.stageHeight / 2;        }            	/**      	 * Hardcode array of items      	 * TODO: this could be refactored to load in from AMF or XML      	 **/        private var data:Array = [								];	}}